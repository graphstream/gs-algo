<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="fr">
<head>
<!-- Generated by javadoc (1.8.0_144) on Wed Jul 15 11:24:51 CEST 2020 -->
<title>Toolkit</title>
<meta name="date" content="2020-07-15">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Toolkit";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":9,"i49":9,"i50":9,"i51":9,"i52":9,"i53":9,"i54":9,"i55":9,"i56":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Toolkit.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/graphstream/algorithm/TarjanStronglyConnectedComponents.IntegerIndexGenerator.html" title="class in org.graphstream.algorithm"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../org/graphstream/algorithm/TopologicalSortDFS.html" title="class in org.graphstream.algorithm"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/graphstream/algorithm/Toolkit.html" target="_top">Frames</a></li>
<li><a href="Toolkit.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.graphstream.algorithm</div>
<h2 title="Class Toolkit" class="title">Class Toolkit</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.graphstream.ui.graphicGraph.GraphPosLengthUtils</li>
<li>
<ul class="inheritance">
<li>org.graphstream.algorithm.Toolkit</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">Toolkit</span>
extends org.graphstream.ui.graphicGraph.GraphPosLengthUtils</pre>
<div class="block">Lots of small often used algorithms on graphs.
 
 <p>
 This class contains a lot of very small algorithms that could be often useful
 with a graph. Most methods take a graph as first argument.
 </p>
 
 <h2>Usage</h2>
 
 <h3>Degrees</h3>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#degreeDistribution-org.graphstream.graph.Graph-"><code>degreeDistribution(Graph)</code></a> method allows to obtain an array where
 each cell index represents the degree, and the value of the cell the number
 of nodes having this degree. Its complexity is O(n) with n the number of
 nodes.
 </p>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#degreeMap-org.graphstream.graph.Graph-"><code>degreeMap(Graph)</code></a> returns an array of nodes sorted by degree in
 descending order. The complexity is O(n log(n)) with n the number of nodes.
 </p>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#averageDegree-org.graphstream.graph.Graph-"><code>averageDegree(Graph)</code></a> returns the average degree. The complexity
 is O(1).
 </p>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#degreeAverageDeviation-org.graphstream.graph.Graph-"><code>degreeAverageDeviation(Graph)</code></a> returns the deviation of the
 average degree. The complexity is O(n) with n the number of nodes.
 </p>
 * <h3>Density</h3>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#density-org.graphstream.graph.Graph-"><code>density(Graph)</code></a> method returns the number of links in the graph
 divided by the total number of possible links. The complexity is O(1).
 </p>
 
 <h3>Diameter</h3>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#diameter-org.graphstream.graph.Graph-"><code>diameter(Graph)</code></a> method computes the diameter of the graph. The
 diameter of the graph is the largest of all the shortest paths from any node
 to any other node.
 </p>
 
 <p>
 The returned diameter is not an integer since some graphs have non-integer
 weights on edges.
 </p>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#diameter-org.graphstream.graph.Graph-java.lang.String-boolean-"><code>diameter(Graph, String, boolean)</code></a> method does the same thing, but
 considers that the graph is weighted if the second argument is non-null. The
 second argument is the weight attribute name. The third argument indicates if
 the graph must be considered as directed or not.
 </p>
 
 <p>
 Note that this operation can be quite costly, the algorithm used depends on
 the fact the graph is weighted or not. If unweighted, the algorithm is in
 O(n*(n+m)). If weighted the algorithm is the Floyd-Warshall algorithm whose
 complexity is at worst of O(n^3).
 </p>
 
 <h3>Clustering coefficient</h3>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#clusteringCoefficient-org.graphstream.graph.Node-"><code>clusteringCoefficient(Node)</code></a> method return the clustering
 coefficient for the given node. The complexity if O(d^2) where d is the
 degree of the node.
 </p>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#clusteringCoefficients-org.graphstream.graph.Graph-"><code>clusteringCoefficients(Graph)</code></a> method return the clustering
 coefficient of each node of the graph as an array.
 </p>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#averageClusteringCoefficient-org.graphstream.graph.Graph-"><code>averageClusteringCoefficient(Graph)</code></a> method return the average
 clustering coefficient for the graph.
 </p>
 
 <h3>Random nodes and edges</h3>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#randomNode-org.graphstream.graph.Graph-"><code>randomNode(Graph)</code></a> returns a node chosen at random in the graph.
 You can alternatively pass a ``Random`` instance as parameter with
 <a href="../../../org/graphstream/algorithm/Toolkit.html#randomNode-org.graphstream.graph.Graph-java.util.Random-"><code>randomNode(Graph, Random)</code></a>. The complexity depends on the kind of
 graph.
 </p>
 
 <p>
 The <a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdge-org.graphstream.graph.Graph-"><code>randomEdge(Graph)</code></a> returns an edge chosen at random in the graph.
 You can alternatively pass a ``Random`` instance as parameter with
 <a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdge-org.graphstream.graph.Graph-java.util.Random-"><code>randomEdge(Graph, Random)</code></a>. The <a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdge-org.graphstream.graph.Node-"><code>randomEdge(Node)</code></a> returns an
 edge chosen at random within the edge set of the given node. You can also use
 <a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdge-org.graphstream.graph.Node-java.util.Random-"><code>randomEdge(Node, Random)</code></a>. To chose a random edge of a node inside
 the entering or leaving edge sets only, you can use
 <a href="../../../org/graphstream/algorithm/Toolkit.html#randomInEdge-org.graphstream.graph.Node-"><code>randomInEdge(Node)</code></a> or <a href="../../../org/graphstream/algorithm/Toolkit.html#randomInEdge-org.graphstream.graph.Node-java.util.Random-"><code>randomInEdge(Node, Random)</code></a>, or
 <a href="../../../org/graphstream/algorithm/Toolkit.html#randomOutEdge-org.graphstream.graph.Node-"><code>randomOutEdge(Node)</code></a> or finally <a href="../../../org/graphstream/algorithm/Toolkit.html#randomOutEdge-org.graphstream.graph.Node-java.util.Random-"><code>randomOutEdge(Node, Random)</code></a>.
 </p>
 
 <h3>Nodes position</h3>
 
 <p>
 Extracting nodes position from attributes can be tricky due to the face the
 positions can be stored either as separate ``x``, ``y`` and ``z`` attributes
 or inside ``xy`` or ``xyz`` attributes.
 </p>
 
 <p>
 To simplify things you can use <code>GraphPosLengthUtils.nodePosition(Node)</code> which returns an
 array of three doubles, containing the position of the node. You can also use
 <code>GraphPosLengthUtils.nodePosition(Graph, String)</code> with a graph and a node identifier.
 </p>
 
 <p>
 If you already have an array of doubles with at least three cells you can
 also use <code>GraphPosLengthUtils.nodePosition(Node, double[])</code> that will store the position
 in the passed array. You can as well use
 <code>GraphPosLengthUtils.nodePosition(Graph, String, double[])</code>.
 </p>
 
 <p>
 All these methods can also handle the ``org.graphstream.ui.geom.Point3``
 class instead of arrays of doubles. Methods that use such an array as
 argument are the same. Methods that return a ``Point3`` instead of an array
 are <code>GraphPosLengthUtils.nodePointPosition(Graph, String)</code> and
 <code>GraphPosLengthUtils.nodePointPosition(Node)</code>.
 </p>
 
 <h3>Cliques</h3>
 
 <p>
 A clique <i>C</i> is a subset of the node set of a graph, such that there
 exists an edge between each pair of nodes in <i>C</i>. In other words, the
 subgraph induced by <i>C</i> is complete. A maximal clique is a clique that
 cannot be extended by adding more nodes, that is, there is no node outside
 the clique connected to all the clique nodes.
 </p>
 
 <p>
 This class provides several methods for dealing with cliques. Use
 <a href="../../../org/graphstream/algorithm/Toolkit.html#isClique-java.util.Collection-"><code>isClique(Collection)</code></a> or <a href="../../../org/graphstream/algorithm/Toolkit.html#isMaximalClique-java.util.Collection-org.graphstream.graph.Graph-"><code>isMaximalClique(Collection, Graph)</code></a>
 to check if a set of nodes is a clique or a maximal clique.
 </p>
 
 <p>
 The methods <a href="../../../org/graphstream/algorithm/Toolkit.html#getMaximalCliqueIterator-org.graphstream.graph.Graph-"><code>getMaximalCliqueIterator(Graph)</code></a> and
 <a href="../../../org/graphstream/algorithm/Toolkit.html#getMaximalCliques-org.graphstream.graph.Graph-"><code>getMaximalCliques(Graph)</code></a> enumerate all the maximal cliques in a
 graph. Iterating on all the maximal cliques of a graph can take much time,
 because their number can grow exponentially with the size of the graph. For
 example, the following naive method to find the maximum clique (that is, the
 largest possible clique) in a graph, is practical only for small and sparse
 graphs.
 </p>
 
 <pre>
 List&lt;Node&gt; maximumClique = new ArrayList&lt;Node&gt;();
 for (List&lt;Node&gt; clique : Toolkit.getMaximalCliques(g))
        if (clique.size() &gt; maximumClique.size())
                maximumClique = clique;
 </pre>
 
 <h2>Example</h2>
 
 <p>
 You can use this class with a static import for example:
 </p>
 
 <pre>
 import static org.graphstream.algorithm.Toolkit.*;
 </pre></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#Toolkit--">Toolkit</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#averageClusteringCoefficient-org.graphstream.graph.Graph-">averageClusteringCoefficient</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Average clustering coefficient of the whole graph.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#averageDegree-org.graphstream.graph.Graph-">averageDegree</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Returns the value of the average degree of the graph.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#clusteringCoefficient-org.graphstream.graph.Node-">clusteringCoefficient</a></span>(org.graphstream.graph.Node&nbsp;node)</code>
<div class="block">Clustering coefficient for one node of the graph.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#clusteringCoefficients-org.graphstream.graph.Graph-">clusteringCoefficients</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Clustering coefficient for each node of the graph.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static java.util.HashMap&lt;java.lang.Object,java.util.HashSet&lt;org.graphstream.graph.Node&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#communities-org.graphstream.graph.Graph-java.lang.String-">communities</a></span>(org.graphstream.graph.Graph&nbsp;graph,
           java.lang.String&nbsp;marker)</code>
<div class="block">Return set of nodes grouped by the value of one attribute (the marker).</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#computeLayout-org.graphstream.graph.Graph-">computeLayout</a></span>(org.graphstream.graph.Graph&nbsp;g)</code>
<div class="block">Compute coordinates of nodes using default layout algorithm and default
 stabilization limit.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#computeLayout-org.graphstream.graph.Graph-double-">computeLayout</a></span>(org.graphstream.graph.Graph&nbsp;g,
             double&nbsp;stab)</code>
<div class="block">Compute coordinates of nodes using default layout algorithm (SpringBox).</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#computeLayout-org.graphstream.graph.Graph-org.graphstream.ui.layout.Layout-double-">computeLayout</a></span>(org.graphstream.graph.Graph&nbsp;g,
             org.graphstream.ui.layout.Layout&nbsp;layout,
             double&nbsp;stab)</code>
<div class="block">Compute coordinates of nodes using a layout algorithm.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#degreeAverageDeviation-org.graphstream.graph.Graph-">degreeAverageDeviation</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Returns the value of the degree average deviation of the graph.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#degreeDistribution-org.graphstream.graph.Graph-">degreeDistribution</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Compute the degree distribution of this graph.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static java.util.ArrayList&lt;org.graphstream.graph.Node&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#degreeMap-org.graphstream.graph.Graph-">degreeMap</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Return a list of nodes sorted by degree, the larger first.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#density-org.graphstream.graph.Graph-">density</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">The density is the number of links in the graph divided by the total
 number of possible links.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#diameter-org.graphstream.graph.Graph-">diameter</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Compute the diameter of the graph.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#diameter-org.graphstream.graph.Graph-java.lang.String-boolean-">diameter</a></span>(org.graphstream.graph.Graph&nbsp;graph,
        java.lang.String&nbsp;weightAttributeName,
        boolean&nbsp;directed)</code>
<div class="block">Compute the diameter of the graph.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#enteringWeightedDegree-org.graphstream.graph.Node-java.lang.String-">enteringWeightedDegree</a></span>(org.graphstream.graph.Node&nbsp;node,
                      java.lang.String&nbsp;weightAttribute)</code>
<div class="block">Compute the weighted entering degree of a given node.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#enteringWeightedDegree-org.graphstream.graph.Node-java.lang.String-double-">enteringWeightedDegree</a></span>(org.graphstream.graph.Node&nbsp;node,
                      java.lang.String&nbsp;weightAttribute,
                      double&nbsp;defaultWeightValue)</code>
<div class="block">Compute the weighted entering degree of a given node.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#fillAdjacencyMatrix-org.graphstream.graph.Graph-int:A:A-">fillAdjacencyMatrix</a></span>(org.graphstream.graph.Graph&nbsp;graph,
                   int[][]&nbsp;matrix)</code>
<div class="block">Fills an array with the adjacency matrix of a graph.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#fillIncidenceMatrix-org.graphstream.graph.Graph-byte:A:A-">fillIncidenceMatrix</a></span>(org.graphstream.graph.Graph&nbsp;graph,
                   byte[][]&nbsp;matrix)</code>
<div class="block">Fills an array with the incidence matrix of a graph.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static int[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#getAdjacencyMatrix-org.graphstream.graph.Graph-">getAdjacencyMatrix</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Returns the adjacency matrix of a graph.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static &lt;T extends org.graphstream.graph.Node&gt;<br>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#getDegeneracy-org.graphstream.graph.Graph-java.util.List-">getDegeneracy</a></span>(org.graphstream.graph.Graph&nbsp;graph,
             java.util.List&lt;T&gt;&nbsp;ordering)</code>
<div class="block">
 This method computes the gedeneracy and the degeneracy ordering of a
 graph.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static byte[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#getIncidenceMatrix-org.graphstream.graph.Graph-">getIncidenceMatrix</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Returns the incidence matrix of a graph.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static &lt;T extends org.graphstream.graph.Node&gt;<br>java.util.Iterator&lt;java.util.List&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#getMaximalCliqueIterator-org.graphstream.graph.Graph-">getMaximalCliqueIterator</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">This iterator traverses all the maximal cliques in a graph.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static &lt;T extends org.graphstream.graph.Node&gt;<br>java.lang.Iterable&lt;java.util.List&lt;T&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#getMaximalCliques-org.graphstream.graph.Graph-">getMaximalCliques</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">An iterable view of the set of all the maximal cliques in a graph.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#illegalArgumentException--">illegalArgumentException</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#isClique-java.util.Collection-">isClique</a></span>(java.util.Collection&lt;? extends org.graphstream.graph.Node&gt;&nbsp;nodes)</code>
<div class="block">Checks if a set of nodes is a clique.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#isConnected-org.graphstream.graph.Graph-">isConnected</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Determines if a graph is (weakly) connected.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#isMaximalClique-java.util.Collection-org.graphstream.graph.Graph-">isMaximalClique</a></span>(java.util.Collection&lt;? extends org.graphstream.graph.Node&gt;&nbsp;nodes,
               org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Checks if a set of nodes is a maximal clique.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#leavingWeightedDegree-org.graphstream.graph.Node-java.lang.String-">leavingWeightedDegree</a></span>(org.graphstream.graph.Node&nbsp;node,
                     java.lang.String&nbsp;weightAttribute)</code>
<div class="block">Compute the weighted leaving degree of a given node.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#leavingWeightedDegree-org.graphstream.graph.Node-java.lang.String-double-">leavingWeightedDegree</a></span>(org.graphstream.graph.Node&nbsp;node,
                     java.lang.String&nbsp;weightAttribute,
                     double&nbsp;defaultWeightValue)</code>
<div class="block">Compute the weighted leaving degree of a given node.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#modularity-double:A:A-">modularity</a></span>(double[][]&nbsp;E)</code>
<div class="block">Compute the modularity of the graph from the E matrix.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#modularity-org.graphstream.graph.Graph-java.lang.String-">modularity</a></span>(org.graphstream.graph.Graph&nbsp;graph,
          java.lang.String&nbsp;marker)</code>
<div class="block">Computes the modularity as defined by Newman and Girvan in "Finding and
 evaluating community structure in networks".</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#modularity-org.graphstream.graph.Graph-java.lang.String-java.lang.String-">modularity</a></span>(org.graphstream.graph.Graph&nbsp;graph,
          java.lang.String&nbsp;marker,
          java.lang.String&nbsp;weightMarker)</code>
<div class="block">Computes the weighted modularity.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#modularityMatrix-org.graphstream.graph.Graph-java.util.HashMap-">modularityMatrix</a></span>(org.graphstream.graph.Graph&nbsp;graph,
                java.util.HashMap&lt;java.lang.Object,java.util.HashSet&lt;org.graphstream.graph.Node&gt;&gt;&nbsp;communities)</code>
<div class="block">Create the modularity matrix E from the communities.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#modularityMatrix-org.graphstream.graph.Graph-java.util.HashMap-java.lang.String-">modularityMatrix</a></span>(org.graphstream.graph.Graph&nbsp;graph,
                java.util.HashMap&lt;java.lang.Object,java.util.HashSet&lt;org.graphstream.graph.Node&gt;&gt;&nbsp;communities,
                java.lang.String&nbsp;weightMarker)</code>
<div class="block">Create the weighted modularity matrix E from the communities.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static org.graphstream.graph.Edge</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdge-org.graphstream.graph.Graph-">randomEdge</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Choose an edge at random.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static org.graphstream.graph.Edge</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdge-org.graphstream.graph.Graph-java.util.Random-">randomEdge</a></span>(org.graphstream.graph.Graph&nbsp;graph,
          java.util.Random&nbsp;random)</code>
<div class="block">Choose an edge at random.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static org.graphstream.graph.Edge</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdge-org.graphstream.graph.Node-">randomEdge</a></span>(org.graphstream.graph.Node&nbsp;node)</code>
<div class="block">Choose an edge at random from the edges connected to the given node.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static org.graphstream.graph.Edge</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdge-org.graphstream.graph.Node-java.util.Random-">randomEdge</a></span>(org.graphstream.graph.Node&nbsp;node,
          java.util.Random&nbsp;random)</code>
<div class="block">Choose an edge at random from the edges connected to the given node.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static java.util.List&lt;org.graphstream.graph.Edge&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdgeSet-org.graphstream.graph.Graph-double-">randomEdgeSet</a></span>(org.graphstream.graph.Graph&nbsp;graph,
             double&nbsp;p)</code>
<div class="block">Returns a random subset of edges.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static java.util.List&lt;org.graphstream.graph.Edge&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdgeSet-org.graphstream.graph.Graph-double-java.util.Random-">randomEdgeSet</a></span>(org.graphstream.graph.Graph&nbsp;graph,
             double&nbsp;p,
             java.util.Random&nbsp;random)</code>
<div class="block">Returns a random subset of edges.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static java.util.List&lt;org.graphstream.graph.Edge&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdgeSet-org.graphstream.graph.Graph-int-">randomEdgeSet</a></span>(org.graphstream.graph.Graph&nbsp;graph,
             int&nbsp;k)</code>
<div class="block">Returns a random subset of edges of fixed size.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static java.util.List&lt;org.graphstream.graph.Edge&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomEdgeSet-org.graphstream.graph.Graph-int-java.util.Random-">randomEdgeSet</a></span>(org.graphstream.graph.Graph&nbsp;graph,
             int&nbsp;k,
             java.util.Random&nbsp;random)</code>
<div class="block">Returns a random subset of edges of fixed size.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static org.graphstream.graph.Edge</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomInEdge-org.graphstream.graph.Node-">randomInEdge</a></span>(org.graphstream.graph.Node&nbsp;node)</code>
<div class="block">Choose an edge at random from the entering edges connected to the given
 node.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>static org.graphstream.graph.Edge</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomInEdge-org.graphstream.graph.Node-java.util.Random-">randomInEdge</a></span>(org.graphstream.graph.Node&nbsp;node,
            java.util.Random&nbsp;random)</code>
<div class="block">Choose an edge at random from the entering edges connected to the given
 node.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static org.graphstream.graph.Node</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomNode-org.graphstream.graph.Graph-">randomNode</a></span>(org.graphstream.graph.Graph&nbsp;graph)</code>
<div class="block">Choose a node at random.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>static org.graphstream.graph.Node</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomNode-org.graphstream.graph.Graph-java.util.Random-">randomNode</a></span>(org.graphstream.graph.Graph&nbsp;graph,
          java.util.Random&nbsp;random)</code>
<div class="block">Choose a node at random.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>static &lt;T extends org.graphstream.graph.Node&gt;<br>java.util.List&lt;org.graphstream.graph.Node&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomNodeSet-org.graphstream.graph.Graph-double-">randomNodeSet</a></span>(org.graphstream.graph.Graph&nbsp;graph,
             double&nbsp;p)</code>
<div class="block">Returns a random subset of nodes.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>static &lt;T extends org.graphstream.graph.Node&gt;<br>java.util.List&lt;org.graphstream.graph.Node&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomNodeSet-org.graphstream.graph.Graph-double-java.util.Random-">randomNodeSet</a></span>(org.graphstream.graph.Graph&nbsp;graph,
             double&nbsp;p,
             java.util.Random&nbsp;random)</code>
<div class="block">Returns a random subset of nodes.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>static java.util.List&lt;org.graphstream.graph.Node&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomNodeSet-org.graphstream.graph.Graph-int-">randomNodeSet</a></span>(org.graphstream.graph.Graph&nbsp;graph,
             int&nbsp;k)</code>
<div class="block">Returns a random subset of nodes of fixed size.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>static &lt;T extends org.graphstream.graph.Node&gt;<br>java.util.List&lt;org.graphstream.graph.Node&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomNodeSet-org.graphstream.graph.Graph-int-java.util.Random-">randomNodeSet</a></span>(org.graphstream.graph.Graph&nbsp;graph,
             int&nbsp;k,
             java.util.Random&nbsp;random)</code>
<div class="block">Returns a random subset of nodes of fixed size.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>static org.graphstream.graph.Edge</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomOutEdge-org.graphstream.graph.Node-">randomOutEdge</a></span>(org.graphstream.graph.Node&nbsp;node)</code>
<div class="block">Choose an edge at random from the leaving edges connected to the given
 node.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static org.graphstream.graph.Edge</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#randomOutEdge-org.graphstream.graph.Node-java.util.Random-">randomOutEdge</a></span>(org.graphstream.graph.Node&nbsp;node,
             java.util.Random&nbsp;random)</code>
<div class="block">Choose an edge at random from the leaving edges connected to the given
 node.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#unweightedEccentricity-org.graphstream.graph.Node-boolean-">unweightedEccentricity</a></span>(org.graphstream.graph.Node&nbsp;node,
                      boolean&nbsp;directed)</code>
<div class="block">Eccentricity of a node not considering edge weights.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#weightedDegree-org.graphstream.graph.Node-java.lang.String-">weightedDegree</a></span>(org.graphstream.graph.Node&nbsp;node,
              java.lang.String&nbsp;weightAttribute)</code>
<div class="block">Compute the weighted degree of a given node.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#weightedDegree-org.graphstream.graph.Node-java.lang.String-double-">weightedDegree</a></span>(org.graphstream.graph.Node&nbsp;node,
              java.lang.String&nbsp;weightAttribute,
              double&nbsp;defaultWeightValue)</code>
<div class="block">Compute the weighted degree of a given node.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>static java.util.ArrayList&lt;org.graphstream.graph.Node&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#weightedDegreeMap-org.graphstream.graph.Graph-java.lang.String-">weightedDegreeMap</a></span>(org.graphstream.graph.Graph&nbsp;graph,
                 java.lang.String&nbsp;weightAttribute)</code>
<div class="block">Return a list of nodes sorted by their weighted degree, the larger first.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>static java.util.ArrayList&lt;org.graphstream.graph.Node&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/graphstream/algorithm/Toolkit.html#weightedDegreeMap-org.graphstream.graph.Graph-java.lang.String-double-">weightedDegreeMap</a></span>(org.graphstream.graph.Graph&nbsp;graph,
                 java.lang.String&nbsp;weightAttribute,
                 double&nbsp;defaultWeightValue)</code>
<div class="block">Return a list of nodes sorted by their weighted degree, the larger first.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.org.graphstream.ui.graphicGraph.GraphPosLengthUtils">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;org.graphstream.ui.graphicGraph.GraphPosLengthUtils</h3>
<code>edgeLength, edgeLength, nodePointPosition, nodePointPosition, nodePosition, nodePosition, nodePosition, nodePosition, nodePosition, nodePosition, positionFromObject, positionFromObject</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Toolkit--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Toolkit</h4>
<pre>public&nbsp;Toolkit()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="weightedDegree-org.graphstream.graph.Node-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedDegree</h4>
<pre>public static&nbsp;double&nbsp;weightedDegree(org.graphstream.graph.Node&nbsp;node,
                                    java.lang.String&nbsp;weightAttribute)</pre>
<div class="block">Compute the weighted degree of a given node. For each entering
 and leaving edge the value contained by the 'weightAttribute' is
 considered. If the edge does not have such an attribute, the value
 one is used instead, resolving to a normal degree. Loop edges are counted
 twice. The 'weightAttribute' must contain a number or the default value
 is used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The node to consider.</dd>
<dd><code>weightAttribute</code> - The name of the attribute to look for weights on edges, it must be a number.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The weighted degree.</dd>
</dl>
</li>
</ul>
<a name="weightedDegree-org.graphstream.graph.Node-java.lang.String-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedDegree</h4>
<pre>public static&nbsp;double&nbsp;weightedDegree(org.graphstream.graph.Node&nbsp;node,
                                    java.lang.String&nbsp;weightAttribute,
                                    double&nbsp;defaultWeightValue)</pre>
<div class="block">Compute the weighted degree of a given node. For each entering
 and leaving edge the value contained by the 'weightAttribute' is
 considered. If the edge does not have such an attribute, the value
 `defaultWeightValue` is used instead. Loop edges are counted twice.
 The 'weightAttribute' must contain a number or the default value
 is used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The node to consider.</dd>
<dd><code>weightAttribute</code> - The name of the attribute to look for weights on edges, it must be a number.</dd>
<dd><code>defaultWeightValue</code> - The default weight value to use if edges do not have the 'weightAttribute'.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The weighted degree.</dd>
</dl>
</li>
</ul>
<a name="enteringWeightedDegree-org.graphstream.graph.Node-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enteringWeightedDegree</h4>
<pre>public static&nbsp;double&nbsp;enteringWeightedDegree(org.graphstream.graph.Node&nbsp;node,
                                            java.lang.String&nbsp;weightAttribute)</pre>
<div class="block">Compute the weighted entering degree of a given node. For each
 entering edge the value contained by the 'weightAttribute' is
 considered. If the edge does not have such an attribute, the value
 one is used instead, resolving to a normal degree. Loop edges are counted once
 if directed, but twice if undirected. The 'weightAttribute' must
 contain a number or the default value is used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The node to consider.</dd>
<dd><code>weightAttribute</code> - The name of the attribute to look on edges, it must be a number.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The entering weighted degree.</dd>
</dl>
</li>
</ul>
<a name="enteringWeightedDegree-org.graphstream.graph.Node-java.lang.String-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enteringWeightedDegree</h4>
<pre>public static&nbsp;double&nbsp;enteringWeightedDegree(org.graphstream.graph.Node&nbsp;node,
                                            java.lang.String&nbsp;weightAttribute,
                                            double&nbsp;defaultWeightValue)</pre>
<div class="block">Compute the weighted entering degree of a given node. For each
 entering edge the value contained by the 'weightAttribute' is
 considered. If the edge does not have such an attribute, the value
 'defaultWeightValue' is used instead. Loop edges are counted once
 if directed, but twice if undirected. The 'weightAttribute' must
 contain a number or the default value is used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The node to consider.</dd>
<dd><code>weightAttribute</code> - The name of the attribute to look on edges, it must be a number.</dd>
<dd><code>defaultWeightValue</code> - The default weight value to use if edges do not have the 'weightAttribute'.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The entering weighted degree.</dd>
</dl>
</li>
</ul>
<a name="leavingWeightedDegree-org.graphstream.graph.Node-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leavingWeightedDegree</h4>
<pre>public static&nbsp;double&nbsp;leavingWeightedDegree(org.graphstream.graph.Node&nbsp;node,
                                           java.lang.String&nbsp;weightAttribute)</pre>
<div class="block">Compute the weighted leaving degree of a given node. For each
 leaving edge the value contained by the 'weightAttribute' is
 considered. If the edge does not have such an attribute, the value
 one is used instead, resolving to a normal degree. Loop edges are counted once
 if directed, but twice if undirected. The 'weightAttribute' must
 contain a number or the default value is used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The node to consider.</dd>
<dd><code>weightAttribute</code> - The name of the attribute to look on edges, it must be a number.</dd>
<dd><code>defaultWeightValue</code> - The default weight value to use if edges do not have the 'weightAttribute'.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The leaving weighted degree.</dd>
</dl>
</li>
</ul>
<a name="leavingWeightedDegree-org.graphstream.graph.Node-java.lang.String-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leavingWeightedDegree</h4>
<pre>public static&nbsp;double&nbsp;leavingWeightedDegree(org.graphstream.graph.Node&nbsp;node,
                                           java.lang.String&nbsp;weightAttribute,
                                           double&nbsp;defaultWeightValue)</pre>
<div class="block">Compute the weighted leaving degree of a given node. For each
 leaving edge the value contained by the 'weightAttribute' is
 considered. If the edge does not have such an attribute, the value
 'defaultWeightValue' is used instead. Loop edges are counted once
 if directed, but twice if undirected. The 'weightAttribute' must
 contain a number or the default value is used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The node to consider.</dd>
<dd><code>weightAttribute</code> - The name of the attribute to look on edges, it must be a number.</dd>
<dd><code>defaultWeightValue</code> - The default weight value to use if edges do not have the 'weightAttribute'.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The leaving weighted degree.</dd>
</dl>
</li>
</ul>
<a name="degreeDistribution-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>degreeDistribution</h4>
<pre>public static&nbsp;int[]&nbsp;degreeDistribution(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Compute the degree distribution of this graph. Each cell of the returned
 array contains the number of nodes having degree n where n is the index
 of the cell. For example cell 0 counts how many nodes have zero edges,
 cell 5 counts how many nodes have five edges. The last index indicates
 the maximum degree.</div>
<dl>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(n) where n is the number of nodes.</dd>
</dl>
</li>
</ul>
<a name="degreeMap-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>degreeMap</h4>
<pre>public static&nbsp;java.util.ArrayList&lt;org.graphstream.graph.Node&gt;&nbsp;degreeMap(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Return a list of nodes sorted by degree, the larger first.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The degree map.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(n log(n)) where n is the number of nodes.</dd>
</dl>
</li>
</ul>
<a name="weightedDegreeMap-org.graphstream.graph.Graph-java.lang.String-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedDegreeMap</h4>
<pre>public static&nbsp;java.util.ArrayList&lt;org.graphstream.graph.Node&gt;&nbsp;weightedDegreeMap(org.graphstream.graph.Graph&nbsp;graph,
                                                                                java.lang.String&nbsp;weightAttribute,
                                                                                double&nbsp;defaultWeightValue)</pre>
<div class="block">Return a list of nodes sorted by their weighted degree, the larger first.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph to consider.</dd>
<dd><code>weightAttribute</code> - The name of the attribute to look for weights on edges, it must be a number, or the default value is used.</dd>
<dd><code>defaultWeightValue</code> - The value to use if the weight attribute is not found on edges.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The degree map.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../org/graphstream/algorithm/Toolkit.html#weightedDegree-org.graphstream.graph.Node-java.lang.String-double-"><code>weightedDegree(Node, String, double)</code></a></dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(n log(n)) where n is the number of nodes.</dd>
</dl>
</li>
</ul>
<a name="weightedDegreeMap-org.graphstream.graph.Graph-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>weightedDegreeMap</h4>
<pre>public static&nbsp;java.util.ArrayList&lt;org.graphstream.graph.Node&gt;&nbsp;weightedDegreeMap(org.graphstream.graph.Graph&nbsp;graph,
                                                                                java.lang.String&nbsp;weightAttribute)</pre>
<div class="block">Return a list of nodes sorted by their weighted degree, the larger first.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph to consider.</dd>
<dd><code>weightAttribute</code> - The name of the attribute to look for weights on edges, it must be a number, or the default value of one is used.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The degree map.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../org/graphstream/algorithm/Toolkit.html#weightedDegree-org.graphstream.graph.Node-java.lang.String-double-"><code>weightedDegree(Node, String, double)</code></a></dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(n log(n)) where n is the number of nodes.</dd>
</dl>
</li>
</ul>
<a name="averageDegree-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>averageDegree</h4>
<pre>public static&nbsp;double&nbsp;averageDegree(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Returns the value of the average degree of the graph. A node with a loop
 edge has degree two.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The average degree of the graph.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(1).</dd>
</dl>
</li>
</ul>
<a name="degreeAverageDeviation-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>degreeAverageDeviation</h4>
<pre>public static&nbsp;double&nbsp;degreeAverageDeviation(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Returns the value of the degree average deviation of the graph.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The degree average deviation.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(n) where n is the number of nodes.</dd>
</dl>
</li>
</ul>
<a name="density-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>density</h4>
<pre>public static&nbsp;double&nbsp;density(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">The density is the number of links in the graph divided by the total
 number of possible links.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The density of the graph.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(1)</dd>
</dl>
</li>
</ul>
<a name="clusteringCoefficients-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clusteringCoefficients</h4>
<pre>public static&nbsp;double[]&nbsp;clusteringCoefficients(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Clustering coefficient for each node of the graph.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An array whose size correspond to the number of nodes, where each
         element is the clustering coefficient of a node.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>at worse O(n d^2) where n is the number of nodes and d the
             average or maximum degree of nodes.</dd>
</dl>
</li>
</ul>
<a name="averageClusteringCoefficient-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>averageClusteringCoefficient</h4>
<pre>public static&nbsp;double&nbsp;averageClusteringCoefficient(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Average clustering coefficient of the whole graph. Average of each node
 individual clustering coefficient.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The average clustering coefficient.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>at worse O(n d^2) where n is the number of nodes and d the
             average or maximum degree of nodes.</dd>
</dl>
</li>
</ul>
<a name="clusteringCoefficient-org.graphstream.graph.Node-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clusteringCoefficient</h4>
<pre>public static&nbsp;double&nbsp;clusteringCoefficient(org.graphstream.graph.Node&nbsp;node)</pre>
<div class="block">Clustering coefficient for one node of the graph. For a node i with
 degree k, if Ni is the neighborhood of i (a set of nodes), clustering
 coefficient of i is defined as the count of edge e_uv with u,v in Ni
 divided by the maximum possible count, ie. k * (k-1) / 2.
 
 This method only works with undirected graphs.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The node to compute the clustering coefficient for.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The clustering coefficient for this node.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(d^2) where d is the degree of the given node.</dd>
<dt><span class="simpleTagLabel">Scientific Reference:</span></dt>
<dd>D. J. Watts and Steven Strogatz (June 1998).
            "Collective dynamics of 'small-world' networks" . Nature 393
            (6684): 440442</dd>
</dl>
</li>
</ul>
<a name="randomNode-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomNode</h4>
<pre>public static&nbsp;org.graphstream.graph.Node&nbsp;randomNode(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Choose a node at random.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A node chosen at random, null if the graph is empty.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(1).</dd>
</dl>
</li>
</ul>
<a name="randomNode-org.graphstream.graph.Graph-java.util.Random-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomNode</h4>
<pre>public static&nbsp;org.graphstream.graph.Node&nbsp;randomNode(org.graphstream.graph.Graph&nbsp;graph,
                                                    java.util.Random&nbsp;random)</pre>
<div class="block">Choose a node at random.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>random</code> - The random number generator to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A node chosen at random, null if the graph is empty.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(1).</dd>
</dl>
</li>
</ul>
<a name="randomEdge-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomEdge</h4>
<pre>public static&nbsp;org.graphstream.graph.Edge&nbsp;randomEdge(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Choose an edge at random.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An edge chosen at random.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(1).</dd>
</dl>
</li>
</ul>
<a name="randomEdge-org.graphstream.graph.Graph-java.util.Random-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomEdge</h4>
<pre>public static&nbsp;org.graphstream.graph.Edge&nbsp;randomEdge(org.graphstream.graph.Graph&nbsp;graph,
                                                    java.util.Random&nbsp;random)</pre>
<div class="block">Choose an edge at random.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>random</code> - The random number generator to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>O(1).</dd>
</dl>
</li>
</ul>
<a name="randomEdge-org.graphstream.graph.Node-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomEdge</h4>
<pre>public static&nbsp;org.graphstream.graph.Edge&nbsp;randomEdge(org.graphstream.graph.Node&nbsp;node)</pre>
<div class="block">Choose an edge at random from the edges connected to the given node.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>O(1).</dd>
</dl>
</li>
</ul>
<a name="randomInEdge-org.graphstream.graph.Node-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomInEdge</h4>
<pre>public static&nbsp;org.graphstream.graph.Edge&nbsp;randomInEdge(org.graphstream.graph.Node&nbsp;node)</pre>
<div class="block">Choose an edge at random from the entering edges connected to the given
 node.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>O(1).</dd>
</dl>
</li>
</ul>
<a name="randomOutEdge-org.graphstream.graph.Node-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomOutEdge</h4>
<pre>public static&nbsp;org.graphstream.graph.Edge&nbsp;randomOutEdge(org.graphstream.graph.Node&nbsp;node)</pre>
<div class="block">Choose an edge at random from the leaving edges connected to the given
 node.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An edge chosen at random, null if the node has no leaving edges.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(1).</dd>
</dl>
</li>
</ul>
<a name="randomEdge-org.graphstream.graph.Node-java.util.Random-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomEdge</h4>
<pre>public static&nbsp;org.graphstream.graph.Edge&nbsp;randomEdge(org.graphstream.graph.Node&nbsp;node,
                                                    java.util.Random&nbsp;random)</pre>
<div class="block">Choose an edge at random from the edges connected to the given node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>random</code> - The random number generator to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An edge chosen at random, null if the node has no edges.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(1).</dd>
</dl>
</li>
</ul>
<a name="randomInEdge-org.graphstream.graph.Node-java.util.Random-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomInEdge</h4>
<pre>public static&nbsp;org.graphstream.graph.Edge&nbsp;randomInEdge(org.graphstream.graph.Node&nbsp;node,
                                                      java.util.Random&nbsp;random)</pre>
<div class="block">Choose an edge at random from the entering edges connected to the given
 node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>random</code> - The random number generator to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An edge chosen at random, null if the node has no entering edges.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(1).</dd>
</dl>
</li>
</ul>
<a name="randomOutEdge-org.graphstream.graph.Node-java.util.Random-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomOutEdge</h4>
<pre>public static&nbsp;org.graphstream.graph.Edge&nbsp;randomOutEdge(org.graphstream.graph.Node&nbsp;node,
                                                       java.util.Random&nbsp;random)</pre>
<div class="block">Choose an edge at random from the leaving edges connected to the given
 node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>random</code> - The random number generator to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An edge chosen at random, null if the node has no leaving edges.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(1).</dd>
</dl>
</li>
</ul>
<a name="communities-org.graphstream.graph.Graph-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>communities</h4>
<pre>public static&nbsp;java.util.HashMap&lt;java.lang.Object,java.util.HashSet&lt;org.graphstream.graph.Node&gt;&gt;&nbsp;communities(org.graphstream.graph.Graph&nbsp;graph,
                                                                                                            java.lang.String&nbsp;marker)</pre>
<div class="block">Return set of nodes grouped by the value of one attribute (the marker).
 For example, if the marker is "color" and in the graph there are nodes
 whose "color" attribute value is "red" and others with value "blue", this
 method will return two sets, one containing all nodes corresponding to
 the nodes whose "color" attribute is red, the other with blue nodes. If
 some nodes do not have the "color" attribute, a third set is returned.
 The returned sets are stored in a hash map whose keys are the values of
 the marker attribute (in our example, the keys would be "red" and "blue",
 and if there are nodes that do not have the "color" attribute, the third
 set will have key "NULL_COMMUNITY").</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>marker</code> - The attribute that allows to group nodes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The communities indexed by the value of the marker.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(n) with n the number of nodes.</dd>
</dl>
</li>
</ul>
<a name="modularityMatrix-org.graphstream.graph.Graph-java.util.HashMap-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>modularityMatrix</h4>
<pre>public static&nbsp;double[][]&nbsp;modularityMatrix(org.graphstream.graph.Graph&nbsp;graph,
                                          java.util.HashMap&lt;java.lang.Object,java.util.HashSet&lt;org.graphstream.graph.Node&gt;&gt;&nbsp;communities)</pre>
<div class="block">Create the modularity matrix E from the communities. The given
 communities are set of nodes forming the communities as produced by the
 <a href="../../../org/graphstream/algorithm/Toolkit.html#communities-org.graphstream.graph.Graph-java.lang.String-"><code>communities(Graph,String)</code></a> method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Graph to which the computation will be applied</dd>
<dd><code>communities</code> - Set of nodes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The E matrix as defined by Newman and Girvan.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(m!k) with m the number of communities and k the average
             number of nodes per community.</dd>
</dl>
</li>
</ul>
<a name="modularityMatrix-org.graphstream.graph.Graph-java.util.HashMap-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>modularityMatrix</h4>
<pre>public static&nbsp;double[][]&nbsp;modularityMatrix(org.graphstream.graph.Graph&nbsp;graph,
                                          java.util.HashMap&lt;java.lang.Object,java.util.HashSet&lt;org.graphstream.graph.Node&gt;&gt;&nbsp;communities,
                                          java.lang.String&nbsp;weightMarker)</pre>
<div class="block">Create the weighted modularity matrix E from the communities. The given
 communities are set of nodes forming the communities as produced by the
 <a href="../../../org/graphstream/algorithm/Toolkit.html#communities-org.graphstream.graph.Graph-java.lang.String-"><code>communities(Graph,String)</code></a> method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - Graph to which the computation will be applied</dd>
<dd><code>communities</code> - Set of nodes.</dd>
<dd><code>weightMarker</code> - The marker used to store the weight of each edge</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The E matrix as defined by Newman and Girvan.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(m!k) with m the number of communities and k the average
             number of nodes per community.</dd>
</dl>
</li>
</ul>
<a name="modularity-double:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>modularity</h4>
<pre>public static&nbsp;double&nbsp;modularity(double[][]&nbsp;E)</pre>
<div class="block">Compute the modularity of the graph from the E matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>E</code> - The E matrix given by <a href="../../../org/graphstream/algorithm/Toolkit.html#modularityMatrix-org.graphstream.graph.Graph-java.util.HashMap-"><code>modularityMatrix(Graph,HashMap)</code></a>
            .</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The modularity of the graph.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(m!) with m the number of communities.</dd>
</dl>
</li>
</ul>
<a name="modularity-org.graphstream.graph.Graph-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>modularity</h4>
<pre>public static&nbsp;double&nbsp;modularity(org.graphstream.graph.Graph&nbsp;graph,
                                java.lang.String&nbsp;marker)</pre>
<div class="block">Computes the modularity as defined by Newman and Girvan in "Finding and
 evaluating community structure in networks". This algorithm traverses the
 graph to count nodes in communities. For this to work, there must exist
 an attribute on each node whose value define the community the node
 pertains to (see <a href="../../../org/graphstream/algorithm/Toolkit.html#communities-org.graphstream.graph.Graph-java.lang.String-"><code>communities(Graph,String)</code></a>).
 
 This method is an utility method that call:
 <ul>
 <li><a href="../../../org/graphstream/algorithm/Toolkit.html#communities-org.graphstream.graph.Graph-java.lang.String-"><code>communities(Graph,String)</code></a></li>
 <li><a href="../../../org/graphstream/algorithm/Toolkit.html#modularityMatrix-org.graphstream.graph.Graph-java.util.HashMap-"><code>modularityMatrix(Graph,HashMap)</code></a></li>
 <li><a href="../../../org/graphstream/algorithm/Toolkit.html#modularity-double:A:A-"><code>modularity(double[][])</code></a></li>
 </ul>
 in order to produce the modularity value.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>marker</code> - The community attribute stored on nodes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The graph modularity.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../org/graphstream/algorithm/measure/Modularity.html" title="class in org.graphstream.algorithm.measure"><code>Modularity</code></a></dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>0(n + m! + m!k) with n the number of nodes, m the number of
             communities and k the average number of nodes per
             communities.</dd>
</dl>
</li>
</ul>
<a name="modularity-org.graphstream.graph.Graph-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>modularity</h4>
<pre>public static&nbsp;double&nbsp;modularity(org.graphstream.graph.Graph&nbsp;graph,
                                java.lang.String&nbsp;marker,
                                java.lang.String&nbsp;weightMarker)</pre>
<div class="block">Computes the weighted modularity. This algorithm traverses the graph to
 count nodes in communities. For this to work, there must exist an
 attribute on each node whose value define the community the node pertains
 to (see <a href="../../../org/graphstream/algorithm/Toolkit.html#communities-org.graphstream.graph.Graph-java.lang.String-"><code>communities(Graph,String)</code></a>) and a attribute on each edge
 storing their weight (all edges without this attribute will be ignored in
 the computation).
 
 This method is an utility method that call:
 <ul>
 <li><a href="../../../org/graphstream/algorithm/Toolkit.html#communities-org.graphstream.graph.Graph-java.lang.String-"><code>communities(Graph,String)</code></a></li>
 <li><a href="../../../org/graphstream/algorithm/Toolkit.html#modularityMatrix-org.graphstream.graph.Graph-java.util.HashMap-java.lang.String-"><code>modularityMatrix(Graph,HashMap,String)</code></a></li>
 <li><a href="../../../org/graphstream/algorithm/Toolkit.html#modularity-double:A:A-"><code>modularity(double[][])</code></a></li>
 </ul>
 in order to produce the modularity value.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>marker</code> - The community attribute stored on nodes.</dd>
<dd><code>weightMarker</code> - The marker used to store the weight of each edge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The graph modularity.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../org/graphstream/algorithm/measure/Modularity.html" title="class in org.graphstream.algorithm.measure"><code>Modularity</code></a></dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>0(n + m! + m!k) with n the number of nodes, m the number of
             communities and k the average number of nodes per
             communities.</dd>
</dl>
</li>
</ul>
<a name="diameter-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>diameter</h4>
<pre>public static&nbsp;double&nbsp;diameter(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Compute the diameter of the graph.
 
 <p>
 The diameter of the graph is the largest of all the shortest paths from
 any node to any other node. The graph is considered non weighted.
 </p>
 
 <p>
 Note that this operation can be quite costly, O(n*(n+m)).
 </p>
 
 <p>
 The returned diameter is not an integer since some graphs have
 non-integer weights on edges. Although this version of the diameter
 algorithm will return an integer.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The diameter.</dd>
</dl>
</li>
</ul>
<a name="diameter-org.graphstream.graph.Graph-java.lang.String-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>diameter</h4>
<pre>public static&nbsp;double&nbsp;diameter(org.graphstream.graph.Graph&nbsp;graph,
                              java.lang.String&nbsp;weightAttributeName,
                              boolean&nbsp;directed)</pre>
<div class="block">Compute the diameter of the graph.
 
 <p>
 The diameter of the graph is the largest of all the shortest paths from
 any node to any other node.
 </p>
 
 <p>
 Note that this operation can be quite costly. Two algorithms are used
 here. If the graph is not weighted (the weightAttributeName parameter is
 null), the algorithm use breath first search from all the nodes to find
 the max depth (or eccentricity) of each node. The diameter is then the
 maximum of these maximum depths. The complexity of this algorithm is
 O(n*(n+m)), with n the number of nodes and m the number of edges.
 </p>
 
 <p>
 If the graph is weighted, the algorithm used to compute all shortest
 paths is the Floyd-Warshall algorithm whose complexity is at worst of
 O(n^3).
 </p>
 
 <p>
 The returned diameter is not an integer since weighted graphs have
 non-integer weights on edges.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph to use.</dd>
<dd><code>weightAttributeName</code> - The name used to store weights on the edges (must be a
            Number).</dd>
<dd><code>directed</code> - Does The edge direction should be considered ?.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The diameter.</dd>
</dl>
</li>
</ul>
<a name="unweightedEccentricity-org.graphstream.graph.Node-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unweightedEccentricity</h4>
<pre>public static&nbsp;int&nbsp;unweightedEccentricity(org.graphstream.graph.Node&nbsp;node,
                                         boolean&nbsp;directed)</pre>
<div class="block">Eccentricity of a node not considering edge weights.
 
 <p>
 The eccentricity is the largest shortest path between the given node and
 any other. It is here computed on number of edges crossed, not
 considering the eventual weights of edges.
 </p>
 
 <p>
 This is computed using a breath first search and looking at the maximum
 depth of the search.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The node for which the eccentricity is to be computed.</dd>
<dd><code>directed</code> - If true, the computation will respect edges direction, if any.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The eccentricity.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(n+m) with n the number of nodes and m the number of edges.</dd>
</dl>
</li>
</ul>
<a name="isClique-java.util.Collection-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isClique</h4>
<pre>public static&nbsp;boolean&nbsp;isClique(java.util.Collection&lt;? extends org.graphstream.graph.Node&gt;&nbsp;nodes)</pre>
<div class="block">Checks if a set of nodes is a clique.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nodes</code> - a set of nodes</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if <code>nodes</code> form a clique</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(<i>k</i>), where <i>k</i> is the size of <code>nodes</code></dd>
</dl>
</li>
</ul>
<a name="isMaximalClique-java.util.Collection-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isMaximalClique</h4>
<pre>public static&nbsp;boolean&nbsp;isMaximalClique(java.util.Collection&lt;? extends org.graphstream.graph.Node&gt;&nbsp;nodes,
                                      org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Checks if a set of nodes is a maximal clique.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nodes</code> - a set of nodes</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if  form a maximal clique</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(<i>kn</i>), where <i>n</i> is the number of nodes in the
             graph and <i>k</i> is the size of <code>nodes</code></dd>
</dl>
</li>
</ul>
<a name="getMaximalCliqueIterator-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaximalCliqueIterator</h4>
<pre>public static&nbsp;&lt;T extends org.graphstream.graph.Node&gt;&nbsp;java.util.Iterator&lt;java.util.List&lt;T&gt;&gt;&nbsp;getMaximalCliqueIterator(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">This iterator traverses all the maximal cliques in a graph. Each call to
 <code>Iterator.next()</code> returns a maximal clique in the form of
 list of nodes. This iterator does not support remove.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - a graph, must not have loop edges</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an iterator on the maximal cliques of <code>graph</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if <code>graph</code> has loop edges</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>This iterator implements the BronKerbosch algorithm. There
             is no guarantee that each call to
             <code>Iterator.next()</code> will run in polynomial
             time. However, iterating over <em>all</em> the maximal
             cliques is efficient in worst case sense. The whole iteration
             takes O(3<sup><i>n</i>/3</sup>) time in the worst case and it
             is known that a <i>n</i>-node graph has at most
             3<sup><i>n</i>/3</sup> maximal cliques.</dd>
</dl>
</li>
</ul>
<a name="illegalArgumentException--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>illegalArgumentException</h4>
<pre>public static&nbsp;void&nbsp;illegalArgumentException()</pre>
</li>
</ul>
<a name="getMaximalCliques-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaximalCliques</h4>
<pre>public static&nbsp;&lt;T extends org.graphstream.graph.Node&gt;&nbsp;java.lang.Iterable&lt;java.util.List&lt;T&gt;&gt;&nbsp;getMaximalCliques(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">An iterable view of the set of all the maximal cliques in a graph. Uses
 <a href="../../../org/graphstream/algorithm/Toolkit.html#getMaximalCliqueIterator-org.graphstream.graph.Graph-"><code>getMaximalCliqueIterator(Graph)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - a graph</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An iterable view of the maximal cliques in <code>graph</code>.</dd>
</dl>
</li>
</ul>
<a name="getDegeneracy-org.graphstream.graph.Graph-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDegeneracy</h4>
<pre>public static&nbsp;&lt;T extends org.graphstream.graph.Node&gt;&nbsp;int&nbsp;getDegeneracy(org.graphstream.graph.Graph&nbsp;graph,
                                                                       java.util.List&lt;T&gt;&nbsp;ordering)</pre>
<div class="block"><p>
 This method computes the gedeneracy and the degeneracy ordering of a
 graph.
 </p>
 
 <p>
 The degeneracy of a graph is the smallest number <i>d</i> such that every
 subgraph has a node with degree <i>d</i> or less. The degeneracy is a
 measure of sparseness of graphs. A degeneracy ordering is an ordering of
 the nodes such that each node has at most <i>d</i> neighbors following it
 in the ordering. The degeneracy ordering is used, among others, in greedy
 coloring algorithms.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - a graph</dd>
<dd><code>ordering</code> - a list of nodes. If not <code>null</code>, this list is first
            cleared and then filled with the nodes of the graph in
            degeneracy order.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the degeneracy of <code>graph</code></dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(<i>m</i>) where <i>m</i> is the number of edges in the
             graph</dd>
</dl>
</li>
</ul>
<a name="fillAdjacencyMatrix-org.graphstream.graph.Graph-int:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillAdjacencyMatrix</h4>
<pre>public static&nbsp;void&nbsp;fillAdjacencyMatrix(org.graphstream.graph.Graph&nbsp;graph,
                                       int[][]&nbsp;matrix)</pre>
<div class="block">Fills an array with the adjacency matrix of a graph.
 
 The adjacency matrix of a graph is a <i>n</i> times <i>n</i> matrix
 <code>a</code>, where <i>n</i> is the number of nodes of the graph. The
 element <code>a[i][j]</code> of this matrix is equal to the number of edges
 from the node <code>graph.getNode(i)</code> to the node
 <code>graph.getNode(j)</code>. An undirected edge between i-th and j-th node
 is counted twice: in <code>a[i][j]</code> and in <code>a[j][i]</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph.</dd>
<dd><code>matrix</code> - The array where the adjacency matrix is stored. Must be of
            size at least <i>n</i> times <i>n</i></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the size of the matrix is insufficient.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../org/graphstream/algorithm/Toolkit.html#getAdjacencyMatrix-org.graphstream.graph.Graph-"><code>getAdjacencyMatrix(Graph)</code></a></dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd><i>O(n<sup>2</sup>)</i>, where <i>n</i> is the number of
             nodes.</dd>
</dl>
</li>
</ul>
<a name="getAdjacencyMatrix-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAdjacencyMatrix</h4>
<pre>public static&nbsp;int[][]&nbsp;getAdjacencyMatrix(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Returns the adjacency matrix of a graph.
 
 The adjacency matrix of a graph is a <i>n</i> times <i>n</i> matrix
 <code>a</code>, where <i>n</i> is the number of nodes of the graph. The
 element <code>a[i][j]</code> of this matrix is equal to the number of edges
 from the node <code>graph.getNode(i)</code> to the node
 <code>graph.getNode(j)</code>. An undirected edge between i-th and j-th node
 is counted twice: in <code>a[i][j]</code> and in <code>a[j][i]</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The adjacency matrix of the graph.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../org/graphstream/algorithm/Toolkit.html#fillAdjacencyMatrix-org.graphstream.graph.Graph-int:A:A-"><code>fillAdjacencyMatrix(Graph, int[][])</code></a></dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd><i>O(n<sup>2</sup>)</i>, where <i>n</i> is the number of
             nodes.</dd>
</dl>
</li>
</ul>
<a name="fillIncidenceMatrix-org.graphstream.graph.Graph-byte:A:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillIncidenceMatrix</h4>
<pre>public static&nbsp;void&nbsp;fillIncidenceMatrix(org.graphstream.graph.Graph&nbsp;graph,
                                       byte[][]&nbsp;matrix)</pre>
<div class="block">Fills an array with the incidence matrix of a graph.
 
 The incidence matrix of a graph is a <i>n</i> times <i>m</i> matrix
 <code>a</code>, where <i>n</i> is the number of nodes and <i>m</i> is the
 number of edges of the graph. The coefficients <code>a[i][j]</code> of this
 matrix have the following values:
 <ul>
 <li>-1 if <code>graph.getEdge(j)</code> is directed and
 <code>graph.getNode(i)</code> is its source.</li>
 <li>1 if <code>graph.getEdge(j)</code> is undirected and
 <code>graph.getNode(i)</code> is its source.</li>
 <li>1 if <code>graph.getNode(i)</code> is the target of
 <code>graph.getEdge(j)</code>.</li>
 <li>0 otherwise.
 </ul>
 In the special case when the j-th edge is a loop connecting the i-th node
 to itself, the coefficient <code>a[i][j]</code> is 0 if the loop is directed
 and 2 if the loop is undirected. All the other coefficients in the j-th
 column are 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph</dd>
<dd><code>matrix</code> - The array where the incidence matrix is stored. Must be at
            least of size <i>n</i> times <i>m</i></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if the size of the matrix is insufficient</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../org/graphstream/algorithm/Toolkit.html#getIncidenceMatrix-org.graphstream.graph.Graph-"><code>getIncidenceMatrix(Graph)</code></a></dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd><i>O(mn)</i>, where <i>n</i> is the number of nodes and
             <i>m</i> is the number of edges.</dd>
</dl>
</li>
</ul>
<a name="getIncidenceMatrix-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIncidenceMatrix</h4>
<pre>public static&nbsp;byte[][]&nbsp;getIncidenceMatrix(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Returns the incidence matrix of a graph.
 
 The incidence matrix of a graph is a <i>n</i> times <i>m</i> matrix
 <code>a</code>, where <i>n</i> is the number of nodes and <i>m</i> is the
 number of edges of the graph. The coefficients <code>a[i][j]</code> of this
 matrix have the following values:
 <ul>
 <li>-1 if <code>graph.getEdge(j)</code> is directed and
 <code>graph.getNode(i)</code> is its source.</li>
 <li>1 if <code>graph.getEdge(j)</code> is undirected and
 <code>graph.getNode(i)</code> is its source.</li>
 <li>1 if <code>graph.getNode(i)</code> is the target of
 <code>graph.getEdge(j)</code>.</li>
 <li>0 otherwise.</li>
 </ul>
 In the special case when the j-th edge is a loop connecting the i-th node
 to itself, the coefficient <code>a[i][j]</code> is 0 if the loop is directed
 and 2 if the loop is undirected. All the other coefficients in the j-th
 column are 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The incidence matrix of the graph.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../org/graphstream/algorithm/Toolkit.html#fillIncidenceMatrix-org.graphstream.graph.Graph-byte:A:A-"><code>fillIncidenceMatrix(Graph, byte[][])</code></a></dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd><i>O(mn)</i>, where <i>n</i> is the number of nodes and
             <i>m</i> is the number of edges.</dd>
</dl>
</li>
</ul>
<a name="computeLayout-org.graphstream.graph.Graph-org.graphstream.ui.layout.Layout-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLayout</h4>
<pre>public static&nbsp;void&nbsp;computeLayout(org.graphstream.graph.Graph&nbsp;g,
                                 org.graphstream.ui.layout.Layout&nbsp;layout,
                                 double&nbsp;stab)</pre>
<div class="block">Compute coordinates of nodes using a layout algorithm.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>g</code> - the graph</dd>
<dd><code>layout</code> - layout algorithm to use for computing coordinates</dd>
<dd><code>stab</code> - stabilization limit</dd>
</dl>
</li>
</ul>
<a name="computeLayout-org.graphstream.graph.Graph-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLayout</h4>
<pre>public static&nbsp;void&nbsp;computeLayout(org.graphstream.graph.Graph&nbsp;g,
                                 double&nbsp;stab)</pre>
<div class="block">Compute coordinates of nodes using default layout algorithm (SpringBox).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>g</code> - the graph</dd>
<dd><code>stab</code> - stabilization limit</dd>
</dl>
</li>
</ul>
<a name="computeLayout-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLayout</h4>
<pre>public static&nbsp;void&nbsp;computeLayout(org.graphstream.graph.Graph&nbsp;g)</pre>
<div class="block">Compute coordinates of nodes using default layout algorithm and default
 stabilization limit.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>g</code> - the graph</dd>
</dl>
</li>
</ul>
<a name="randomNodeSet-org.graphstream.graph.Graph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomNodeSet</h4>
<pre>public static&nbsp;java.util.List&lt;org.graphstream.graph.Node&gt;&nbsp;randomNodeSet(org.graphstream.graph.Graph&nbsp;graph,
                                                                       int&nbsp;k)</pre>
<div class="block">Returns a random subset of nodes of fixed size. Each node has the same
 chance to be chosen.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph.</dd>
<dd><code>k</code> - The size of the subset.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A random subset of nodes of size <code>k</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If <code>k</code> is negative or greater than the number of
             nodes.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(<code>k</code>)</dd>
</dl>
</li>
</ul>
<a name="randomNodeSet-org.graphstream.graph.Graph-int-java.util.Random-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomNodeSet</h4>
<pre>public static&nbsp;&lt;T extends org.graphstream.graph.Node&gt;&nbsp;java.util.List&lt;org.graphstream.graph.Node&gt;&nbsp;randomNodeSet(org.graphstream.graph.Graph&nbsp;graph,
                                                                                                              int&nbsp;k,
                                                                                                              java.util.Random&nbsp;random)</pre>
<div class="block">Returns a random subset of nodes of fixed size. Each node has the same
 chance to be chosen.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph.</dd>
<dd><code>k</code> - The size of the subset.</dd>
<dd><code>random</code> - A source of randomness.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A random subset of nodes of size <code>k</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If <code>k</code> is negative or greater than the number of
             nodes.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(<code>k</code>)</dd>
</dl>
</li>
</ul>
<a name="randomNodeSet-org.graphstream.graph.Graph-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomNodeSet</h4>
<pre>public static&nbsp;&lt;T extends org.graphstream.graph.Node&gt;&nbsp;java.util.List&lt;org.graphstream.graph.Node&gt;&nbsp;randomNodeSet(org.graphstream.graph.Graph&nbsp;graph,
                                                                                                              double&nbsp;p)</pre>
<div class="block">Returns a random subset of nodes. Each node is chosen with given
 probability.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph.</dd>
<dd><code>p</code> - The probability to choose each node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A random subset of nodes.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If <code>p</code> is negative or greater than one.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>In average O(<code>n * p<code>), where <code>n</code> is the
             number of nodes.</dd>
</dl>
</li>
</ul>
<a name="randomNodeSet-org.graphstream.graph.Graph-double-java.util.Random-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomNodeSet</h4>
<pre>public static&nbsp;&lt;T extends org.graphstream.graph.Node&gt;&nbsp;java.util.List&lt;org.graphstream.graph.Node&gt;&nbsp;randomNodeSet(org.graphstream.graph.Graph&nbsp;graph,
                                                                                                              double&nbsp;p,
                                                                                                              java.util.Random&nbsp;random)</pre>
<div class="block">Returns a random subset of nodes. Each node is chosen with given
 probability.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph.</dd>
<dd><code>p</code> - The probability to choose each node.</dd>
<dd><code>random</code> - A source of randomness.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A random subset of nodes.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If <code>p</code> is negative or greater than one.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>In average O(<code>n * p<code>), where <code>n</code> is the
             number of nodes.</dd>
</dl>
</li>
</ul>
<a name="randomEdgeSet-org.graphstream.graph.Graph-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomEdgeSet</h4>
<pre>public static&nbsp;java.util.List&lt;org.graphstream.graph.Edge&gt;&nbsp;randomEdgeSet(org.graphstream.graph.Graph&nbsp;graph,
                                                                       int&nbsp;k)</pre>
<div class="block">Returns a random subset of edges of fixed size. Each edge has the same
 chance to be chosen.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph.</dd>
<dd><code>k</code> - The size of the subset.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A random subset of edges of size <code>k</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If <code>k</code> is negative or greater than the number of
             edges.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(<code>k</code>)</dd>
</dl>
</li>
</ul>
<a name="randomEdgeSet-org.graphstream.graph.Graph-int-java.util.Random-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomEdgeSet</h4>
<pre>public static&nbsp;java.util.List&lt;org.graphstream.graph.Edge&gt;&nbsp;randomEdgeSet(org.graphstream.graph.Graph&nbsp;graph,
                                                                       int&nbsp;k,
                                                                       java.util.Random&nbsp;random)</pre>
<div class="block">Returns a random subset of edges of fixed size. Each edge has the same
 chance to be chosen.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph.</dd>
<dd><code>k</code> - The size of the subset.</dd>
<dd><code>random</code> - A source of randomness.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A random subset of edges of size <code>k</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If <code>k</code> is negative or greater than the number of
             edges.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(<code>k</code>)</dd>
</dl>
</li>
</ul>
<a name="randomEdgeSet-org.graphstream.graph.Graph-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomEdgeSet</h4>
<pre>public static&nbsp;java.util.List&lt;org.graphstream.graph.Edge&gt;&nbsp;randomEdgeSet(org.graphstream.graph.Graph&nbsp;graph,
                                                                       double&nbsp;p)</pre>
<div class="block">Returns a random subset of edges. Each edge is chosen with given
 probability.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph.</dd>
<dd><code>p</code> - The probability to choose each edge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A random subset of edges.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If <code>p</code> is negative or greater than one.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>In average O(<code>m * p<code>), where <code>m</code> is the
             number of edges.</dd>
</dl>
</li>
</ul>
<a name="randomEdgeSet-org.graphstream.graph.Graph-double-java.util.Random-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomEdgeSet</h4>
<pre>public static&nbsp;java.util.List&lt;org.graphstream.graph.Edge&gt;&nbsp;randomEdgeSet(org.graphstream.graph.Graph&nbsp;graph,
                                                                       double&nbsp;p,
                                                                       java.util.Random&nbsp;random)</pre>
<div class="block">Returns a random subset of edges. Each edge is chosen with given
 probability.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph.</dd>
<dd><code>p</code> - The probability to choose each edge.</dd>
<dd><code>random</code> - A source of randomness.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A random subset of edges.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If <code>p</code> is negative or greater than one.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>In average O(<code>m * p<code>), where <code>m</code> is the
             number of edges.</dd>
</dl>
</li>
</ul>
<a name="isConnected-org.graphstream.graph.Graph-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>isConnected</h4>
<pre>public static&nbsp;boolean&nbsp;isConnected(org.graphstream.graph.Graph&nbsp;graph)</pre>
<div class="block">Determines if a graph is (weakly) connected.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - A graph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the graph is connected.</dd>
<dt><span class="simpleTagLabel">Computational Complexity:</span></dt>
<dd>O(<code>m + n</code>) where <code>m</code> is the number of edges and <code>n</code> is the number of nodes.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Toolkit.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/graphstream/algorithm/TarjanStronglyConnectedComponents.IntegerIndexGenerator.html" title="class in org.graphstream.algorithm"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../org/graphstream/algorithm/TopologicalSortDFS.html" title="class in org.graphstream.algorithm"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/graphstream/algorithm/Toolkit.html" target="_top">Frames</a></li>
<li><a href="Toolkit.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
